<!DOCTYPE html>
<html>

<head>
    <title>Nano Multisignature Tool</title>
    <!-- Compiled with wasm feature by rust 1.40.0 then stripped by wabt 1.0.12-1 -->

    <!-- nano-base32 from https://github.com/termhn/nano-base32/blob/d6b160aba47595180b67cc8a30096a11525e4010/index.js -->
    <script src="nano-base32.js"></script>

    <!-- blake2b from https://github.com/emilbayes/blake2b/blob/f0a7c7b550133eca5f5fc3b751ccfd2335ce736f/index.js -->
    <script src="blake2b.js"></script>

    <script>

        let wasm;
        const imports = {
            wasi_unstable: {
                fd_write: (fd, iovs, iovsLen, nwritten) => {
                    console.error("fd_write called: unimplemented");
                    return 0;
                },
                random_get: (ptr, len) => {
                    crypto.getRandomValues(new Uint8Array(wasm.memory.buffer, ptr, len));
                    return 0;
                }
            }
        };
        window.addEventListener("load", function () {
			request = new XMLHttpRequest();
			request.open('GET', 'musig.wasm');
			request.send();

			request.onload = function() {
				var wasmString = request.responseText;
				const wasmBytes = new Uint8Array(wasmString.length);
		        for (let i = 0; i < wasmString.length; i++) {
		            wasmBytes[i] = wasmString.charCodeAt(i);
		        }

				WebAssembly.instantiate(wasmBytes, imports).then(w => {
					wasm = w.instance.exports;
	                main();
				});
			};
        });
        function calculateAddressChecksum(pubkey) {
            const blake2b = new Blake2b(5);
            blake2bUpdate(blake2b, pubkey);
            const out = new Uint8Array(5);
            blake2bFinal(blake2b, out);
            out.reverse();
            return out;
        }
        function byteArraysEqual(a, b) {
            if (a.length !== b.length) {
                return false;
            }
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        }
        function copyToWasm(bytes, ptr) {
            if (!ptr) {
                ptr = wasm.musig_malloc(bytes.length);
            }
            const buf = new Uint8Array(wasm.memory.buffer, ptr, bytes.length);
            for (let i = 0; i < bytes.length; i++) {
                buf[i] = bytes[i];
            }
            return ptr;
        }
        function copyFromWasm(ptr, length) {
            const out = new Uint8Array(length);
            for (let i = 0; i < length; i++) {
                out[i] = wasm.memory.buffer[ptr + i];
            }
            return out;
        }
        function alertError(f) {
            return function () {
                try {
                    f();
                } catch (err) {
                    console.error(err);
                    alert(err.toString());
                }
            };
        }
        function fromHexString(hexString) {
            return new Uint8Array(hexString.match(/.{2}/g).map(byte => parseInt(byte, 16)));
        }
        function toHexString(bytes) {
            return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
        }
        const wasmErrors = ["No error", "Internal WASM error", "Invalid parameter(s) passed to WASM", "Invalid peer message specified"];
        function wasmError(errCode) {
            throw new Error("WASM error " + errCode + ": " + wasmErrors[errCode]);
        }
        function main() {
            const addressesInput = document.getElementById("addressesTextBox");
            let numAddresses;
            function aggregate(runWithPubkeys) {
                const addresses = addressesInput.value.trim().split("\n");
                if (addresses.length < 2) {
                    throw new Error("This requires at least 2 newline-separated addresses");
                }
                numAddresses = addresses.length;
                const pubkeys = [];
                for (let address of addresses) {
                    address = address.trim();
                    if (!address.startsWith("xrb_") && !address.startsWith("nano_")) {
                        throw new Error("Nano addresses must start with xrb_ or nano_");
                    }
                    address = address.split("_", 2)[1];
                    try {
                        const bytes = decode(address);
                        if (bytes.length !== 37) {
                            throw new Error("Wrong nano address length");
                        }
                        const pubkey = bytes.subarray(0, 32);
                        const checksum = calculateAddressChecksum(pubkey);
                        if (!byteArraysEqual(bytes.subarray(32), checksum)) {
                            throw new Error("Invalid nano address checksum");
                        }
                        pubkeys.push(pubkey);
                    } catch (err) {
                        console.error(err);
                        throw new Error("Invalid nano address (bad character?)");
                    }
                }
                const pubkeyPtrs = wasm.musig_malloc(pubkeys.length * 4);
                const pubkeyPtrsBuf = new Uint32Array(wasm.memory.buffer, pubkeyPtrs, pubkeys.length);
                for (let i = 0; i < pubkeys.length; i++) {
                    pubkeyPtrsBuf[i] = copyToWasm(pubkeys[i]);
                }
                const outPtr = wasm.musig_malloc(33);
                const outBuf = new Uint8Array(wasm.memory.buffer, outPtr, 33);
                outBuf[0] = 0;
                wasm.musig_aggregate_public_keys(pubkeyPtrs, pubkeys.length, outPtr, outPtr + 1);
                if (runWithPubkeys) runWithPubkeys(pubkeyPtrs, pubkeys.length);
                for (let i = 0; i < pubkeyPtrsBuf.length; i++) {
                    wasm.musig_free(pubkeyPtrsBuf[i]);
                }
                wasm.musig_free(pubkeyPtrs);
                const err = outBuf[0];
                if (err !== 0) {
                    wasm.musig_free(outPtr);
                    throw wasmError(err);
                }
                const aggPubkey = outBuf.subarray(1).slice();
                const checksum = calculateAddressChecksum(aggPubkey);
                const fullAddress = new Uint8Array(37);
                for (let i = 0; i < 32; i++) {
                    fullAddress[i] = aggPubkey[i];
                }
                for (let i = 0; i < 5; i++) {
                    fullAddress[32 + i] = checksum[i];
                }
                document.getElementById("aggregateOut").innerText = "nano_" + encode(fullAddress);
                wasm.musig_free(outPtr);
                return aggPubkey;
            }
            const aggregateButton = document.getElementById("aggregateButton");
            aggregateButton.addEventListener("click", alertError(aggregate));
            const messageInput = document.getElementById("messageInput");
            const advanceMusigButton = document.getElementById("advanceMusigButton");
            const privateKeyInput = document.getElementById("privateKeyInput");
            const protocolOut = document.getElementById("protocolOut");
            const protocolInTextBox = document.getElementById("protocolInTextBox");
            let musigStagePtr, musigStageNum;
            advanceMusigButton.addEventListener("click", alertError(function () {
                if (!musigStagePtr) {
                    if (!/^[a-fA-F0-9]{64}$/.test(privateKeyInput.value)) {
                        throw new Error("Invalid private key");
                    }
                    if (!/^([a-fA-F0-9]{2})*$/.test(messageInput.value)) {
                        throw new Error("Message isn't valid hexadecimal");
                    }
                    const privateKeyPtr = copyToWasm(fromHexString(privateKeyInput.value));
                    const outPtr = wasm.musig_malloc(65);
                    const outBuf = new Uint8Array(wasm.memory.buffer, outPtr, 65);
                    outBuf[0] = 0;
                    let aggPubKey;
                    try {
                        aggPubKey = aggregate((pubkeys, pubkeysLen) => {
                            musigStagePtr = wasm.musig_stage0(privateKeyPtr, pubkeys, pubkeysLen, 0, outPtr, outPtr + 1, outPtr + 33);
                            musigStageNum = 0;
                        });
                    } catch (err) {
                        if (musigStagePtr) {
                            wasm.musig_free_stage0(musigStagePtr);
                        }
                        musigStagePtr = undefined;
                        musigStageNum = undefined;
                        throw err;
                    } finally {
                        wasm.musig_free(privateKeyPtr);
                    }
                    const err = outBuf[0];
                    if (err !== 0) {
                        musigStagePtr = undefined;
                        musigStageNum = undefined;
                        wasm.musig_free(outPtr);
                        throw wasmError(err);
                    }
                    if (!byteArraysEqual(aggPubKey, outBuf.subarray(1, 33))) {
                        wasm.musig_free_stage0(musigStagePtr);
                        musigStagePtr = undefined;
                        musigStageNum = undefined;
                        wasm.musig_free(outPtr);
                        throw new Error("Specified private key not in the list of public keys");
                    }
                    privateKeyInput.disabled = true;
                    privateKeyInput.value = privateKeyInput.value.slice(0, 2) + "*".repeat(60) + privateKeyInput.value.slice(62);
                    messageInput.readOnly = true;
                    addressesInput.readOnly = true;
                    aggregateButton.disabled = true;
                    advanceMusigButton.innerText = "Advance Multisignature";
                    document.getElementById("protocolInDiv").style.display = "block";
                    document.getElementById("protocolOutDiv").style.display = "block";
                    protocolOut.innerText = toHexString(outBuf.subarray(33));
                    wasm.musig_free(outPtr);
                } else {
                    const protocolInputs = protocolInTextBox.value.trim().split("\n").map(s => s.trim().toLowerCase());
                    let expectedLen = numAddresses - 1;
                    if (protocolInputs.includes(protocolOut.innerText)) expectedLen++;
                    if (protocolInputs.length != expectedLen) {
                        throw new Error("Wrong number of inputs from other participants:" +
                            " expected 1 for each other participant (and optionally our own input)");
                    }
                    const protocolInputPtrs = wasm.musig_malloc(protocolInputs.length * 4);
                    const protocolInputPtrsBuf = new Uint32Array(wasm.memory.buffer, protocolInputPtrs, protocolInputs.length);
                    for (let i = 0; i < protocolInputs.length; i++) {
                        protocolInputPtrsBuf[i] = copyToWasm(fromHexString(protocolInputs[i]));
                    }
                    const outLen = (musigStageNum === 2) ? 65 : 33;
                    const outPtr = wasm.musig_malloc(outLen);
                    const outBuf = new Uint8Array(wasm.memory.buffer, outPtr, outLen);
                    outBuf[0] = 0;
                    let newStagePtr;
                    if (musigStageNum === 0) {
                        newStagePtr = wasm.musig_stage1(musigStagePtr, protocolInputPtrs, protocolInputs.length, outPtr, outPtr + 1);
                    } else if (musigStageNum === 1) {
                        const message = fromHexString(messageInput.value);
                        const messagePtr = copyToWasm(message);
                        newStagePtr = wasm.musig_stage2(musigStagePtr, messagePtr, message.length, protocolInputPtrs, protocolInputs.length, outPtr, outPtr + 1);
                        wasm.musig_free(messagePtr);
                    } else if (musigStageNum === 2) {
                        newStagePtr = wasm.musig_stage3(musigStagePtr, protocolInputPtrs, protocolInputs.length, outPtr, outPtr + 1);
                    } else {
                        wasm.musig_free(outPtr);
                        throw new Error("Unexpected musigStageNum " + musigStageNum);
                    }
                    const err = outBuf[0];
                    if (err !== 0) {
                        wasm.musig_free(outPtr);
                        if (err === 1) {
                            // Now in an invalid state
                            protocolInTextBox.disabled = true;
                            advanceMusigButton.disabled = true;
                        }
                        throw wasmError(err);
                    }
                    musigStagePtr = newStagePtr;
                    musigStageNum++;
                    protocolOut.innerText = toHexString(outBuf.subarray(1));
                    protocolInTextBox.value = "";
                    document.getElementById("stageNumber").innerText = musigStageNum.toString();
                    if (musigStageNum === 3) {
                        protocolInTextBox.disabled = true;
                        advanceMusigButton.disabled = true;
                        document.getElementById("protocolOutDesc").innerText = "Finished signature";
                    }
                    wasm.musig_free(outPtr);
                }
            }));
        }
    </script>
</head>

<body>
    <h1>Nano Multisignature Tool</h1>
    <h3>Participating Nano Addresses</h3>
    <textarea id="addressesTextBox" cols="65" rows="5"></textarea><br>
    <button id="aggregateButton">Aggregate</button>&nbsp;<span id="aggregateOut"></span><br>

    <h2>Perform Multisignature</h2>
    <label for="privateKeyInput">Private Key:</label>
    <input name="privateKeyInput" id="privateKeyInput" size="64" maxlength="64" autocomplete="off"><br>
    <label for="messageInput">Message to sign (in hexadecimal):</label>
    <input name="messageInput" id="messageInput" size="64"><br>

    <div id="protocolInDiv" style="display: none">
        <h3>Stage <span id="stageNumber">0</span> input from other participants</h3>
        <textarea id="protocolInTextBox" cols="65" rows="5" autocomplete="off"></textarea>
    </div>

    <button id="advanceMusigButton">Begin Multisignature</button><br>

    <div id="protocolOutDiv" style="display: none">
        <span id="protocolOutDesc">Next stage input for other participants</span>: <span id="protocolOut"></span><br>
    </div>

    <br><button onclick="window.location.reload()">Reset</button>
</body>

</html>
